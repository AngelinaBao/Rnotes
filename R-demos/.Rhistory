head(mtcars)
fit0 <- lm(mpg ~ hp + wt + hp:wt, data = mtcars)
summary(fit0)
mean(mtcars$wt)
sd(mtcars$wt)
install.packages("effects")
library(effects)
plot(effct("hp:wt", fit0, list(wt = c(2.2, 3.2, 4.2))), multiline = TRUE)
plot(effect("hp:wt", fit0, list(wt = c(2.2, 3.2, 4.2))), multiline = TRUE)
fit0 <- lm(mpg ~ hp + wt + hp:wt, data = mtcars)
summary(fit0)
library(effects)
plot(effect("hp:wt", fit0, list(wt = c(2.2, 3.2, 4.2))), multiline = TRUE)
?effect
plot(effect("hp:wt", fit0,, list(wt = c(2.2, 3.2, 4.2))), multiline = TRUE)
confint(fit)
fit1 <- lm(weight ~ height, data = women)
par(mfrow = c(2,2))
plot(fit)
fit1 <- lm(weight ~ height, data = women)
par(mfrow = c(2,2))
plot(fit)
plot(fit1)
fit2 <- lm(weight ~ height + I(height^2), data = women)
par(mfrow = c(2,2))
plot(fit2)
fit3 <- lm(weight ~ height + I(height^2), data = women)
fit3 <- lm(weight ~ height + I(height^2), data = women[c(-13, -15),])
plot(fit3)
fit3 <- lm(weight ~ height + I(height^2), data = women[-c(13, 15),])
plot(fit3)
colnames(state.x77)
states <- as.data.frame(state.x77[, c("Murder", "Population", "Illiteracy", "Income", "Frost")])
fit <- lm(Murder ~ Population + Illiteracy + Income + Frost, data = states)
?layout
layout(1:4,2,2, byrow = T)
layout(1:4,2,2, byrow = TRUE)
layout(matrix(1:4,2,2, byrow = T))
plot(fit)
head(state.x77,3)
rownames(state.x77)
states <- states[-c("Nevada"),]
View(states)
View(states)
states["nevada",]
states <- states[-"Nevada",]
states["nevada",]
states <- states[-28,]
fit <- lm(Murder ~ Population + Illiteracy + Income + Frost, data = states)
plot(fit)
library(car)
help(package = "car")
?qqplot
qqplot(fit, lablel = row.names(states), id.method = "identify"
simulate = T, main = "Q-Q Plot")
qqplot(fit, lablel = row.names(states), id.method = "identify",
simulate = T, main = "Q-Q Plot")
states <- as.data.frame(state.x77[, c("Murder", "Population", "Illiteracy", "Income", "Frost")])
fit <- lm(Murder ~ Population + Illiteracy + Income + Frost, data = states)
qqplot(fit, lablel = row.names(states), id.method = "identify",
simulate = T, main = "Q-Q Plot")
rm(list=ls())
gc()
states <- as.data.frame(state.x77[, c("Murder", "Population", "Illiteracy", "Income", "Frost")])
fit <- lm(Murder ~ Population + Illiteracy + Income + Frost, data = states)
library(car)
qqplot(fit, lablel = row.names(states), id.method = "identify",
simulate = T, main = "Q-Q Plot")
qqPlot(fit, lablel = row.names(states), id.method = "identify",
simulate = T, main = "Q-Q Plot")
qqPlot(fit, lablel = row.names(states), id.method = "identify",
simulate = T, main = "Q-Q Plot")
qqPlot(fit, lablels = row.names(states), id.method = "identify",
simulate = T, main = "Q-Q Plot")
states["Navada",]
states["Nevada",]
fitted(fit)["Nevada",]
fitted(fit)["Nevada"]
residuals(fit)["Nevada"]
residuals(fit)["Nevada"]+fitted(fit)["Nevada"]
?rstudent
rstudent(fit)["Nevada"]
states1 <- states[-"Nevada",]
states1 <- states[-28,]
fit_new <- lm(Murder ~ Population + Illiteracy + Income + Frost, data = states1)
fitted(fit_new)
mean(fitted(fit_new))
summary(fit_new)
qqPlot(fit_new, labels = row.names(states1), simulate = T, main = "NEw QQ Plot")
residplot(fit)
residplot <- function(fit, nbreaks=10) {
z <- rstudent(fit)
hist(z, breaks=nbreaks, freq=FALSE,
xlab="Studentized Residual",
main="Distribution of Errors")
rug(jitter(z), col="brown")
curve(dnorm(x, mean=mean(z), sd=sd(z)),
add=TRUE, col="blue", lwd=2)
lines(density(z)$x, density(z)$y,
col="red", lwd=2, lty=2)
legend("topright",
legend = c( "Normal Curve", "Kernel Density Curve"),
lty=1:2, col=c("blue","red"), cex=.7)
}
residplot(fit)
durbinWatsonTest(fit)
states <- as.data.frame(state.x77[, c("Murder", "Population", "Illiteracy", "Income", "Frost")])
fit <- lm(Murder ~ Population + Illiteracy + Income + Frost, data = states)
qqPlot(fit, lablels = row.names(states), id.method = "identify",
simulate = T, main = "Q-Q Plot")
states["Nevada",]
fitted(fit)["Nevada"]
residuals(fit)["Nevada"]
rstudent(fit)["Nevada"]
durbinWatsonTest(fit)
crPlots(fit)
ncvTest(fit)
spreadLevelPlot(fit)
spreadLevelPlot(fit)
options(digit = 2)
ncvTest(fit)
spreadLevelPlot(fit)
options(digit = default)
install.packages("gvlma")
library(gvlma)
summary(gvmodel)
gvmodel <- gvlma(fit)
summary(gvmodel)
vif(fit)
sqrt(vif(fit)) > 2
outlierTest(fit)
outlierTest(fit_new)
identify(1:n, hatvalues(fit), names(hatvalues(fit)))
#帽子统计法(hat statistic)
hat.plot <- function(fit){
p <- length(coefficients(fit))
n <- length(fitted(fit))
plot(hatvalues(fit), main = "Index Plot of Hat Values")
abline(h = c(2,3)*p/n, col = "red", lty = 2)
identify(1:n, hatvalues(fit), names(hatvalues(fit)))
}
hat.plot(fit)
fitted(fit)["Alaska"]
residuals(fitted(fit)["Alaska"])
residuals(fit)["Alaska"]
states["Alaska",]
?plot
cutoff <- 4/(length(rownames(states))- length(coefficients(fit))- 2)
plot(fit, cook.levels = cutoff)
plot(fit, which =4, cook.levels = cutoff)
plot(fit, which =2, cook.levels = cutoff)
plot(fit, which =4, cook.levels = cutoff)
abline(h = cuotoff, lty = 2, col = "red")
abline(h = cutoff, lty = 2, col = "red")
coefficients(fit)
fit$coefficients
avPlots(fit, ask = FALSE, id.method = "identify")
warnings()
avPlots(fit, ask = FALSE)
?avPlots
avPlots(fit, ask = FALSE, cex = .5)
avPlots(fit_new, ask = FALSE, id.method = "identify")
avPlots(fit_new, ask = FALSE)
warnings()
avPlots(fit_new, ask = FALSE)
avPlots(fit, ask = FALSE, cex = .5)
avPlots(fit_new, ask = FALSE)
rownames(states)
states2 <- states[-2, ]
fit_newer <- lm(Murder ~ Population + Illiteracy + Income + Frost, data = states2)
avPlots(fit_newer)
summary(fit_newer)
summary(fit)
?influencePlot
influencePlot(fit, id.method = "identify", main = "Influence Plot",
sub = "Circle Size is proportional to Cook's Distance")
influencePlot(fit, id = list(method = "identify"), main = "Influence Plot",
sub = "Circle Size is proportional to Cook's Distance")
avPlots(fit_new, ask = FALSE, id = list(method = "identify"))
avPlots(fit, ask = FALSE, id = list(method = "identify"))
influencePlot(fit, id = list(method = "identify"), main = "Influence Plot",
sub = "Circle Size is proportial to Cook's Distance")
summary(powerTransform(states$Murder))
boxTidwell(Murder ~ Population + Illiteracy, data = states)
spreadLevelPlot(fit)
fit1 <- lm(Murder ~ Population + Illiteracy, data = states)
anova(fit, fit1)
AIC(fit, fit1)
library(Mass)
install.packages("Mass")
library(Mass)
install.packages("Mass")
install.packages("MASS")
install.packages("MASS")
library(Mass)
library(MASS)
stepAIC(fit, direction = "backward")
stepAIC(fit, direction = "both")
?step
step(fit, direction = "both")
install.packages("leaps")
library(leaps)
leap <- regsubsets(Murder ~ Population + Illiteracy + Income + Frost, data = states)
?plot
plot(leap)
plot(leap, scale = "adjr2")
?subsets
library(car)
?subsets
subsets(leap, statistic = "cp", main = "Cp Plot for All Subsets Regression")
abline(1,1, lty = 2, col = "red")
leap <- regsubsets(Murder ~ Population + Illiteracy + Income + Frost, data = states, nbest = 4)
leap <- regsubsets(Murder ~ Population + Illiteracy + Income + Frost, data = states, nbest = 4)
plot(leap, scale = "adjr2")
subsets(leap, statistic = "cp", main = "Cp Plot for All Subsets Regression")
abline(1,1, lty = 2, col = "red")
?plot
library(car)
states <- as.data.frame(state.x77[, c("Murder", "Population", "Illiteracy", "Income", "Frost")])
fit <- lm(Murder ~ Population + Illiteracy + Income + Frost, data = states)
qqPlot(fit, lablels = row.names(states), id.method = "identify",
simulate = T, main = "Q-Q Plot")
fitted(fit)["Nevada"]
residuals(fit)["Nevada"]
#独立性检验
durbinWatsonTest(fit)
#独立性检验
durbinWatsonTest(fit) #p值不显著（p=0.282）说明无自相关性，误差项之间独立。
#滞后项（lag=1）表明数据集中每个数据都是与其后一个数据进行比较的。
#线性检验
crPlots(fit)
#同方差性检验
ncvTest(fit)
spreadLevelPlot(fit)
#多重共线性判断
vif(fit)
sqrt(vif(fit)) > 2
#帽子统计法(hat statistic)
hat.plot <- function(fit){
p <- length(coefficients(fit))
n <- length(fitted(fit))
plot(hatvalues(fit), main = "Index Plot of Hat Values")
abline(h = c(2,3)*p/n, col = "red", lty = 2)
identify(1:n, hatvalues(fit), names(hatvalues(fit)))
}
states <- as.data.frame(state.x77[, c("Murder", "Population", "Illiteracy", "Income", "Frost")])
fit <- lm(Murder ~ Population + Illiteracy + Income + Frost, data = states)
hat.plot(fit)
install.packages(c("gplots", "HH", "rrcov", "multicomp", "effects", "mvoutlier"))
help(aov, package = "car")
rm(list = ls())
gc()
library(multcomp)
attach(cholesterol)
head(cholesterol)
table(cholesterol)
class(cholesterol)
table(trt)
aggregate(response, by = list(trt), FUN = mean)
aggregate(response, by = list(trt), FUN = sd)
fit <- aov(response ~ trt)
summary(fit)
library(gplots)
plotmeans(response ~ trt, xlab = "Treatment", ylab = "Response",
main = "Mean Plot \nwith 95% CI")
TukeyHSD(fit)
?par
plot(TukeyHSD(fit))
par(las = 2)
plot(TukeyHSD(fit))
par(mar = c(5,8,4,2))
plot(TukeyHSD(fit))
?TukeyHSD
#Method 2
library(multcomp)
par(mar = c(5,6,4,2))
?glht
glht(fit, linfct = mcp(trt = "Tukey"))
tuk <- glht(fit, linfct = mcp(trt = "Tukey"))
tuk <- glht(fit, linfct = mcp(trt = "Tukey"))
plot(cld(tuk, .05), col = "lightgrey")
par(las = 2)
plot(cld(tuk, .05), col = "lightgrey") #cld设置显著水平
par(mar = c(5,4,6,2))
plot(cld(tuk, .05), col = "lightgrey") #cld设置显著水平
par(mar = c(4,4,8,2))
plot(cld(tuk, .05), col = "lightgrey") #cld设置显著水平
par(mar = c(5,4,6,2))
plot(cld(tuk, .05), col = "lightgrey") #cld设置显著水平
#有相同字母的组说明差异不显著，1time和2times差异不显著，1time和4times差异显著
#假设检验
library(car)
detach(cholesterol)
qqplot(lm(response ~ trt), data = cholesterol, simulate = T, main = "QQ Plot")
qqplot(lm(response ~ trt, data = cholesterol), simulate = T, main = "QQ Plot")
qqPlot(lm(response ~ trt, data = cholesterol), simulate = T, main = "QQ Plot")
#当simulate=TRUE时， 95%的置信区间将会用参数自助法生成
#qqPlot要用lm()拟合
#齐方差性检验
bartlett.test(response ~ trt, data = cholesterol)
#p=0.9653 说明五组的方差并无显著不同
#齐方差性对离群点非常敏感，所以要检查是否存在离群点
outlier.test(fit)
#p=0.9653 说明五组的方差并无显著不同
#齐方差性对离群点非常敏感，所以要检查是否存在离群点
outlierTest(fit)
data(litter, package = "multcomp")
head(litter)
head(cholesterol)
attach(cholesterol)
data(cholesterol, package = "multcomp")
head(cholesterol)
attach(litter)
table(dose)
?aggregate
aggregate(weight, by = list(dose), FUN = mean)
colnames(litter)
fit <- aov(weight ~ gesttime + dose)
summary(fit)
#剂量与出生体重相关
#由于使用了协变量，你可能想获取调整的组均值，即去除协变量效应后的组均值
library(effects)
?effect
effect("dose", fit)
？glht
?glht
#剂量的F检验只说明了不同处理方式幼崽的出生体重均值不同，但没有说明哪一种处理
#方式与其它方式不同
#与单因素方差分析类似，我们使用multcomp包对所有均值进行成对比较
#multcomp包可以对用户自定义的均值假设进行检验
#假设我们想研究未用药条件与其它三种用药条件是否影响不同
library(multcomp)
?glht
contrast <- rbind("no drug vs .drug" = c(3, -1, -1, -1))
contrast
?mcp
summary(glht(fit, linfct = mcp(dose = contrast)))
#假设检验，ANCOVA假定正态性、同方差性以及回归斜率相同
#正态性检验
library(car)
qqPlot(lm(weight ~ gesttime + dose, data = litter simulate = T,
qqPlot(lm(weight ~ gesttime + dose, data = litter), simulate = T,
main = "Q-Q Plot")
#数据落在95%置信区间内，说明满足正态性假设
#同方差性
bartlett.test(weight ~ gesttime + dose, data = litter)
?bartlett.test
#数据落在95%置信区间内，说明满足正态性假设
#同方差性
bartlett.test(lm(weight ~ gesttime + dose, data = litter))
#数据落在95%置信区间内，说明满足正态性假设
#同方差性
bartlett.test(weight ~ gesttime*dose, data = litter)
#数据落在95%置信区间内，说明满足正态性假设
#同方差性
bartlett.test(weight ~ dose, data = litter)
#数据落在95%置信区间内，说明满足正态性假设
#ANOVA模型包含怀孕时间*剂量的交互项时，可对回归斜率的同质性进行检验
library(multcomp)
fit2 <- aov(weight ~ gesttim * dose, data = litter)
fit2 <- aov(weight ~ gesttime * dose, data = litter)
summary(fit2)
#结果可视化
#HH包中的ancova()可以绘制因变量、协变量和因子之间的关系图
library(HH)
anvova(weight ~ gesttime + dose, data = litter)
ancova(weight ~ gesttime + dose, data = litter)
#可以看出，用怀孕时间来预测出生体重的回归线相互平行，只是截距不同，出生体重随
#怀孕时间的增加而增加，0剂量组出生体重最大，5剂量组出生体重最小
ancova(weight ~ gesttime*dose, data = litter)
#双因素方差分析
head(ToothGrowth)
tail(ToothGrowth)
attach(ToothGrowth)
detach(litter)
attach(ToothGrowth)
rm(list = ls())
gc()
attach(ToothGrowth)
table(supp, dose)
aggregate(len, by = list(supp, dose), FUN = mean)
aggregate(len, by = list(supp, dose), FUN = sd)
dose <- factor(dose)
fit <- aov(len ~ supp * dose)
summary(fit)
#结果可视化
#interaction.plot()可以展示双因素方差分析的交互效应
interaction.plot(dose, supp, len,
col = c("red", "blue"),
pch = c(16, 18),
main = "Interaction Plot of Dose& Supp")
#结果可视化
#interaction.plot()可以展示双因素方差分析的交互效应
interaction.plot(dose, supp, len,
type = "b"
col = c("red", "blue"),
pch = c(16, 18),
main = "Interaction Plot of Dose& Supp")
#结果可视化
#interaction.plot()可以展示双因素方差分析的交互效应
interaction.plot(dose, supp, len,
type = "b",
col = c("red", "blue"),
pch = c(16, 18),
main = "Interaction Plot of Dose& Supp")
#结果表明，随剂量的增加，牙齿长长，0.5和1剂量时，orange比VC更促进牙齿生长
#其它交互方法：plotmeans() & interaction2Wt()
library(gplots)
plotmeans(len ~ interaction(supp, dose, seq = " "),
connect = list(c(1,3,5), c(2,4,6)),
col = c("red", "darkgreen"),
main = "Interaction Plot with 95% CIs",
xlab = "Treatment and Dose Combination")
?plotmeans
library(HH)
interaction2wt(len ~ supp * dose)
#重复测量方差分析
head(CO2)
attach(CO2)
conc <- factor(cnoc)
conc <- factor(CO2$cnoc)
class(CO2$conc)
CO2$conc <- factor(CO2$cnoc)
rm(conc)
CO2$conc <- factor(CO2$cnoc)
CO2$conc <- factor(CO2$conc)
CO2$conc <- factor(CO2$cnoc)
CO2$conc <- factor(CO2$conc)
CO2$conc <- factor(CO2$conc)
colnames(CO2)
#含一个组间因子和一个组内因子的重复测量方差分析
head(CO2)
?aov()
?Error
w1b1 <- subset(CO2, Treatment == "chilled")
w1b1
#含一个组间因子和一个组内因子的重复测量方差分析
head(CO2)
fit <- aov(uptake ~ conc*Type + Error(Plant/conc), w1b1)
summary(fit)
getwd()
setwd("g:/数据分析/R-demos")
getwd()
rm(list = ls())
?gc
gc()
?sink
sink("myoutput", append = T, split = T)
#append = T 可以将文本追加到文件后，而不是覆盖它,split = T可以同时输出到文件和屏幕
pdf("mygraph.pdf")
source("Pie Chart Demos.R")
sink()
dev.off()
sink("myoutput", append = T, split = T)
#append = T 可以将文本追加到文件后，而不是覆盖它,split = T可以同时输出到文件和屏幕
pdf("mygraph.pdf")
source("Pie_Chart_Demos.R")
sink()
dev.off()
a <- data.frame(apple = c(1,2,3), banana = c(2,5,7))
sink("myoutput", append = T, split = T)
sink()
a <- data.frame(apple = c(1,2,3), banana = c(2,5,7))
sink()
source(a)
rm(list = ls())
gc()
sink("myoutput", append = T, split = T)
#append = T 可以将文本追加到文件后，而不是覆盖它,split = T可以同时输出到文件和屏幕
pdf("mygraph.pdf")
source("script.R")
sink()
dev.off()
source("script.R")
sink()
?sink
?write.table
rm(list = ls())
gc()
library()
library(car)
detach("package:car", unload = T)
install.packages("car")
search()
help(package = "car")
data(package = "car")
ma <- matrix(1:18, nrow = 6, ncol = 3, byrow = T, dimnames = c("a", "b", "c"))
dimnames = list(c("a", "b", "c", "d", "e", "f"), c(1,2,3))
ma <- matrix(1:18, nrow = 6, ncol = 3, byrow = T,
）
ma <- matrix(1:18, nrow = 6, ncol = 3, byrow = T,dimnames = list(c("a", "b", "c", "d", "e", "f"), c(1,2,3))
)
ma <- matrix(1:18, nrow = 6, ncol = 3, byrow = T,dimnames = list(c("a", "b", "c", "d", "e", "f"), c(1,2,3))
)
ma <- matrix(1:18, nrow = 6, ncol = 3, byrow = T,
dimnames = list(c("a", "b", "c", "d", "e", "f"), c(1,2,3)))
ma
ar <- array(1:24, dim = c(3,4,2))
ar
dim1 <- c("a", "b", "c")
dim2 <- c("apple", "banana", "kiwi", "fruit", "orange")
dim3 <- c("group1", "group2")
names(ar) <- list(dim, dim, dim)
ar
dimnames(ar) <- list(dim, dim, dim)
ar <- array(1:24, dim = c(3,4,2))
ar
?names
ar <- array(1:24, dim = c(3,4,2),dimnames = list(dim1, dim2, dim3))
dim2 <- c("apple", "banana", "kiwi", "fruit")
ar <- array(1:24, dim = c(3,4,2),dimnames = list(dim1, dim2, dim3))
ar
