exp(1)
e
10^2
10^6
1e+08
log(1e+08)
exp(2)
exp(8)
#DT[i, j, by] -- Take DT, subset rows use i, then caculate j grouped by 'by'
library(data.table)
set.seed(45L)
DT <- data.table(V1 = c(1L, 2L),
V2 = letters[1:3],
V3 = round(rnorm(4), 2),
V4 = 1:12)
# Subsetting rows using i
DT[3:5,] #select third to fifth row
DT[3:5] # same as above
DT[V2 == "a"]
DT[V2 %in% c("a", "c")]
# Manipulating on columns in j
DT[, V2]  # select 1 col in j, and it returns a vector
DT[, .(V2, V3)] #select several cols inj, and it returns a data.table
DT[, ":=" (V1 = round(exp(V1), 2), V2 = LETTERS[4:6])]
DT[, ":=" (V1 = round(exp(V1), 2), V2 = LETTERS[4:6], V5 = letters[2:4])][] #[] will display the result on screen
#remove a column also can use :=
DT[, V5 := NULL]
DT
DT <- data.table(V1 = c(1L, 2L),
V2 = letters[1:3],
V3 = round(rnorm(4), 2),
V4 = 1:12)
DT[, ":=" (V1 = round(exp(V1), 2), V2 = LETTERS[4:6], V5 = letters[2:4])][] #[] will display the result on screen
DT[, ":=" (V1 = NULL, V5 = NULL)]
DT
Cols.choose = c("A", "B")
DT[, Cols.choose := NULL]
DT[, (Cols.choose) := NULL]
View(DT)
DT <- data.table(V1 = c(1L, 2L),
V2 = letters[1:3],
V3 = round(rnorm(4), 2),
V4 = 1:12)
DT[, ":=" (V1 = round(exp(V1), 2), V2 = LETTERS[4:6], V5 = letters[2:4])][] #[] will display the result on screen
Cols.choose = c("V1", "V5")
DT[, (Cols.choose) := NULL]
DT <- data.table(V1 = c(1L, 2L),
V2 = letters[1:3],
V3 = round(rnorm(4), 2),
V4 = 1:12)
# Indexing and keys
setkey(DT, V2)
haskey(DT)
setkey(DT, NULL)
haskey(DT) # check if a data.table has key
setkey(DT, V2)
DT["C"]
DT["A"]
DT
DT["a"]
DT[c("a", "c")]
DT[V2 %in% c("a", "c")]
#The mult argument is used to control which row that i matches to isreturned, default is all.
DT["a", mult = "first"]
DT[c("a", "c"), mult = "last"]
#nomatch argument is used to control the value if no match situation
#default is NA, but can be changed to 0
DT[c("a", "d")]
DT[c("a", "d"), nomatch = 0]
DT[c("a", "d"), nomatch = 0]
#by=.EACHI allows to group by each subset of known groups in i.
#A key needs to be set to use by=.EACHI.
DT[c("a", "c"), sum(V4)]
DT[c("a", "c"), sum(V4), by = .EACHI]
DT
#Any number of columns can be set as key using setkey(). This way rows can
#be selected on 2 keys which is an equijoin.
setkey(DT, V1, V2)
DT[.(2, "c")]
DT[.(2, c("a", "c"))]
DT[.(c(2, 1), "b")]
DT[.(1:2, "a")]
#advanced data table operations
# .N contains the number of rows or the last row
DT[.N]
DT[.N-1]
tail(DT, 3)
DT[.N-2]
DT[.N-3]
DT[.N-2]
# usable in j
DT[, .N]
DT[, .N-1]
#.() is an alias to list() and means the same. The .() notation is not
#needed when there is only one item in by or j.
DT[, .(V2, V3)]
DT[, list(V2, V3)]
DT[, sum(V4), by = .(V1, V2)]
# .SD is a data.table and holds all the values of all columns, except the
#one specified in by. It reduces programming time but keeps
# readability. .SD is only accessible in j.
DT[, print(.SD), by = V2]
DT[, print(.SD), by = V1]
DT[, .SD[c(1, .N)], by = V2]
# .SD is a data.table and holds all the values of all columns, except the
#one specified in by. It reduces programming time but keeps
# readability. .SD is only accessible in j.
DT[, print(.SD), by = V2]
DT[, .SD[c(1, 3), by = V2]]
DT[, .SD[c(1, 3)], by = V2]
# .SD is a data.table and holds all the values of all columns, except the
#one specified in by. It reduces programming time but keeps
# readability. .SD is only accessible in j.
DT[, print(.SD), by = V2]
DT[, lapply(.SD, sum), by = V2]
DT[, sum, V2]
#.SDcols is used together with .SD, to specify a subset of the columns of
#.SD to be used in j.
DT[, lapply(.SD, sum), by = V2, .SDcols = c("V3", "V4")]
#.SDcols can be the result of a function call.
DT[, lapply(.SD, sum), by = V2, .SDcols = paste0("V", 3:4)]
#Do 2 (or more) sets of statements at once by chaining them in one statement. This
#corresponds to having in SQL.
DT[, .(sum.V4 = sum(V4)), by = V1]
DT[sum.V4 > 40]
DT
#Do 2 (or more) sets of statements at once by chaining them in one statement. This
#corresponds to having in SQL.
DT[, .(sum.V4 := sum(V4)), by = V1]
#Do 2 (or more) sets of statements at once by chaining them in one statement. This
#corresponds to having in SQL.
DT[, sum.V4 := sum(V4), by = V1]
DT
DT[sum.V4 > 40]
DT <- data.table(V1 = c(1L, 2L),
V2 = letters[1:3],
V3 = round(rnorm(4), 2),
V4 = 1:12)
#Do 2 (or more) sets of statements at once by chaining them in one statement. This
#corresponds to having in SQL.
DT <- DT[, .(sum.V4 = sum(V4)), by = V1]
DT[sum.V4 > 40]
DT
DT <- data.table(V1 = c(1L, 2L),
V2 = letters[1:3],
V3 = round(rnorm(4), 2),
V4 = 1:12)
DT[, .(sum.V4 = sum(V4)), by = V1][sum.V4 > 40]
DT[, .(sum.V4 = sum(V4)), by = V1][order[-V1]]
DT[, .(sum.V4 = sum(V4)), by = V1][order(-V1)]
setnames(DT, "V1", "Number")
DT
setnames(DT, c("V2", "V3"), c("Rank", "Rating"))
DT <- data.table(V1 = c(1L, 2L),
V2 = letters[1:3],
V3 = round(rnorm(4), 2),
V4 = 1:12)
setnames(DT, c("V2", "V3"), c("Rank", "Rating"))[]
DT <- data.table(V1 = c(1L, 2L),
V2 = letters[1:3],
V3 = round(rnorm(4), 2),
V4 = 1:12)
setcolorder(DT, c("V4", "V1", "V3", "V2"))
DT
DT[-V2]
DT[,-V2]
