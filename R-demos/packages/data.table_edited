# DT[i, j, by] -- "take DT, subset rows using i, then calculate j grouped by by"

library(data.table)
set.seed(45L)
DT <- data.table(V1 = c(1L, 2L), V2 = LETTERS[1:3], V3 = round(rnorm(4), 4), V4 = 1:12)

DT[3:5] #Selects third to fifth row.
DT[3:5,] #Selects third to fifth row.
DT[V2 == "A"] #Selects all rows that have value A in column V2.
DT[V2 %in% c("A", "C")] #Select all rows that have the value A or C in column V2.

DT[, V2] #Column V2 is returned as a vector
DT[, "V2"] #Column V2 is returned as a dataframe

DT[, .(V2, V3)] #Column V2 is returned as a vector.
DT[, 2:3]#select two and three column
DT[, c("V2", "V3", "V4")] #select two to four column

DT[3:5,c("V1", "V2", "V4")] #select third to fifth rows and one, two, four columns
DT[3:5, .(V1, V2, V4)]#select third to fifth rows and one, two, four columns

#.() is an alias to list(). If .() is used, the returned value is a data.table. 
#If .() is not used, the result is a vector.

####Manipulating on columns in j

DT[, sum(V1)] #call functions in j, Returns the sum of all elements of column V1 in a vector.
DT[, .(sum(V1), round(sd(V3), 4))] #Returns the sum of all elements of column V1 and the 
#standard deviation of V3 in a data.table.
DT[, .(Sum_V1 = sum(V1), Sd_V3 = round(sd(V3), 4))] #The same with above, but with new names
DT[, {
  print(V2)
  plot(V3)
}] #Multiple expressions can be wrapped in curly braces;Print column V2 and plot V3.


###Doing J by Group
DT[, .(sum_V4 = sum(V4)), by = V1] #Calculates the sum of V4, for every group in V1.
DT[, .(sum_V4 = sum(V4)), by = .(V1, V2)] #The same as above, but for every group in V1 and V2
DT[, .(sum_V4 = sum(V4)), by = sign(V1 - 1)] #Call functions in by. Calculates the sum of V4,
#for every group in sign(V1-1)
DT[, .(sum_V4 = sum(V4)), by = .(sign_V1 = sign(V1 - 1))] # The same as above, but with a new name for variable in group by
DT[1:5, .(sum_V4 = sum(V4)), by = V2] # grouping only subset(one to five rows) of DT
DT[, .N, by = V2] #Using .N to get the total number of observations of each group.
DT[, .N, by = .(V2, V1)]

##.N is used to get the total number of observations of each group.


###ADDING/UPDATING COLUMNS BY REFERENCE IN USING :=
DT[, V1 := round(exp(V1), 2)] #column V1 is updated by what is after :=
#DT[, .(V1, V2) := .(round(exp(V1), 2), LETTERS[4:6])] this is wrong!
DT[, c("V1", "V2") := .(round(log(V1), 2), LETTERS[4:6])] #Column V1 and V2 are updated by what is after :=.

DT[, ':='(V1 = round(log(V1), 2), V2 = LETTERS[1:3])] [] 
#Another way to write the same line as above this one, but easier to write
#comments side-by-side. Also, when [] is added the result is printed to the screen
DT[, ':='(V1 = round(log(V1), 2), V2 = LETTERS[1:3])] #The same as above, but the result isn't printed to the screen

DT[, V1 := NULL] #remove column V1
DT[, c("V2", "V3") := NULL] #remove column V2&V3
DT[, ':='(V1 = NULL, V4 = NULL)] #remove columns by using function ':='

col_choosen <- c("V1", "V2")
DT[, (col_choosen) := NULL] #remove column V1 and V2, just same as DT[, c("V1", "V2)]


## Indexing and Keys
setkey(DT, V2) #A key is set on column V2.The data is sorted on the column 
#we specified by reference.
DT["A"] #Returns all the rows where the key column (set to column V2 in the line above) 
#has the value A.
DT[c("B", "C")] #Returns all the rows where the key column (V2) has the value A or C.

##The mult argument is used to control which row that i matches to is 
#returned, default is all.
DT["A", mult = "first"] #Returns first row of all rows that match the value A in the key column (V2).
DT[c("A", "C"), mult = "first"] #return first row that matches value A and value C respectively
DT["A", mult = "second"] #this is wrong, because mult argument can only be "all",
# "first", "last"

##The nomatch argument is used to control what happens when a value specified in i has
#no match in the rows of the DT. Default is NA, but can be changed to 0.
#0 means no rows will be returned for that non-matched row of i. nomatch can only be NA or 0
DT[c("A", "D")] #Returns all the rows where the key column (V2) has the value A or D.
#D is not found, so return NA by default
DT[c("A", "D"), nomatch = 0] 



##by=.EACHI allows to group by each subset of known groups in i. A key needs to be set 
#to use by=.EACHI.
DT[c("A", "C"), sum(V4)] #return sum of V4, for the rows of the key column (V2) that have values A or C.
DT[c("A", "C"), .(sum_V4 = sum(V4))] #the same as above, only add a column name for sum(V4) 
DT[c("A", "C"), .(sum_V4 = sum(V4)), by = .EACHI]
#Returns one sum of column V4 for the rows of column V2 that have value A, and
#another sum for the rows of column V2 that have value C.

##Any number of columns can be set as key using setkey(). This way rows can be selected 
#on 2 keys which is an equijoin.
setkey(DT, V1, V2) #Sorts by column V1 and then by column V2 within each group of column V1.
DT[.(2, "A")] #Selects the rows that have the value 2 for the first key (column V1) and 
#the value C for the second key (column V2).
DT[.(2, c("A", "C"))] #Selects the rows that have the value 2 for the 
#first key (column V1) and within those rows the value A or C for the second key (column V2).
setkey(DT, NULL) #remove key in DT
haskey(DT)


##ADVANCED DATA TABLE OPERATIONS
##.N contains the number of rows or the last row.
DT[.N-1] #Returns the penultimate row of the data.table.
DT[, .N] #Returns the number of rows.
DT[.N] #return the last row of the data.table

#.() is an alias to list() and means the same. The .() notation is not
#needed when there is only one item in by or j.
DT[, list(V2, V3)]
DT[, .(V2, V3)] #the same as above
all.equal(DT[, list(V2, V3)], DT[, .(V2, V3)])

DT[, mean(V3), by = .(V1, V2)]
DT[, mean(V3), by = V1]

##.SD is a data.table and holds all the values of all columns, except the one specified in 
#by. It reduces programming time but keeps readability. .SD is only accessible in j.
DT[, print(.SD), by = V2] #To look at what .SD contains.
DT[, .SD[c(1, .N)]]#select the first and last row in .SD
DT[, .SD[c(1, .N)], by = V2]#Selects the first and last row grouped by column V2.
DT[, lapply(.SD, sum), by = V2]
DT[, .(sum(V1), sum(V3), sum(V4)), by = V2] #the same as above

#.SDcols is used together with .SD, to specify a subset of the columns of .SD to be used 
#in j.
DT[, lapply(.SD, sum), by = V2, .SDcols = c("V3", "V4")] #calculate the V3&V4 column of .SD by V2
#.SDcols can be the result of a function call.
DT[, lapply(.SD, sum), by = V2, .SDcols = paste0("V", 3:4)] #the same as line above


##Do 2 (or more) sets of statements at once by chaining them in one statement. This
#corresponds to having in SQL.
DT <- DT[, .(sum_V4 = sum(V4)), by = V2] #just like group by in SQL
DT[sum_V4 > 25] #corresponds to having syntax in SQL
#or:
DT[, .(sum_V4 = sum(V4)), by = V2][sum_V4 > 25]
DT[, .(sum_V4 = sum(V4)), by = V1][order(-V1)] #Calculates sum of V4, grouped by V1, 
#and then orders the result on V1.


##setnames() is used to create or update column names by reference.
#setnames(DT, "old", "new")[] change the old name to new one, [] is used to print the result to screen
setnames(DT, "V2", "rate") #change the "V2" to "rate"
colnames(DT)
setnames(DT, c("V1", "V3"), c("Number", "percent")) #Changes two column names.

##setcolorder() is used to reorder columns by reference.
#setcolorder(DT, "neworder") neworder is a character vector of the new column name ordering
setcolorder(DT, c("rate", "Number", "V4", "percent")) #Changes the column ordering to the contents of the vector.
head(DT)
